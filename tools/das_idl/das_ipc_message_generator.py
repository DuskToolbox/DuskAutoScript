"""
DAS IPC 消息结构生成器

从 IDL 接口定义生成 IPC 消息结构体代码。

功能:
1. 为每个接口方法生成 Request/Response 消息结构体
2. 遵循 B2.2 消息结构规范（40 bytes header, alignas(8)）
3. 支持命名空间

输出文件命名: <InterfaceName>Messages.h

消息结构规范:
- IPCMessageHeaderV2: 40 bytes, alignas(8)
  - object_id: uint64_t (8 bytes)
  - interface_id: uint32_t (4 bytes) - FNV-1a hash
  - call_id: uint32_t (4 bytes)
  - method_id: uint16_t (2 bytes)
  - flags: uint16_t (2 bytes)
  - payload_size: uint32_t (4 bytes)
  - reserved: uint64_t (8 bytes)
  - timestamp: uint64_t (8 bytes)
"""

import os
from datetime import datetime, timezone
from pathlib import Path
from typing import List, Optional
import importlib
import sys

# 既支持作为包内模块导入（tools.das_idl.*），也支持直接脚本运行。
try:
    from . import das_idl_parser as _das_idl_parser
except ImportError:
    this_dir = str(Path(__file__).resolve().parent)
    if this_dir not in sys.path:
        sys.path.insert(0, this_dir)
    _das_idl_parser = importlib.import_module("das_idl_parser")

IdlDocument = _das_idl_parser.IdlDocument
InterfaceDef = _das_idl_parser.InterfaceDef
MethodDef = _das_idl_parser.MethodDef
ParameterDef = _das_idl_parser.ParameterDef
TypeInfo = _das_idl_parser.TypeInfo
ParamDirection = _das_idl_parser.ParamDirection


class IpcMessageTypeMapper:
    """IPC 消息类型映射器"""

    # IDL 类型到 C++ 类型的映射
    TYPE_MAP = {
        'bool': 'bool',
        'int8': 'int8_t',
        'int16': 'int16_t',
        'int32': 'int32_t',
        'int32_t': 'int32_t',
        'int64': 'int64_t',
        'int64_t': 'int64_t',
        'uint8': 'uint8_t',
        'uint16': 'uint16_t',
        'uint32': 'uint32_t',
        'uint32_t': 'uint32_t',
        'uint64': 'uint64_t',
        'uint64_t': 'uint64_t',
        'float': 'float',
        'double': 'double',
        'size_t': 'size_t',
        'int': 'int32_t',
        'uint': 'uint32_t',
        'DasResult': 'DasResult',
        'DasBool': 'DasBool',
        'DasGuid': 'DasGuid',
        'char': 'char',
    }

    @classmethod
    def get_cpp_type(cls, type_info: TypeInfo) -> str:
        """将 IDL 类型转换为 C++ 类型"""
        base = cls.TYPE_MAP.get(type_info.base_type, type_info.base_type)

        result = ""
        if type_info.is_const:
            result += "const "

        result += base

        if type_info.is_pointer:
            result += "*" * type_info.pointer_level

        if type_info.is_reference:
            result += "&"

        return result

    @classmethod
    def get_interface_short_name(cls, interface_name: str) -> str:
        """从接口名获取短名称（去掉 I 前缀）
        
        IDasLogger -> DasLogger
        """
        if interface_name.startswith('IDas'):
            return interface_name[1:]
        if interface_name.startswith('I') and len(interface_name) > 1:
            return interface_name[1:]
        return interface_name


class IpcMessageGenerator:
    """IPC 消息结构代码生成器"""

    def __init__(self, document: IdlDocument, idl_file_path: Optional[str] = None):
        self.document = document
        self.idl_file_path = idl_file_path
        self.idl_file_name = os.path.basename(idl_file_path) if idl_file_path else None
        self.indent = "    "  # 4 空格缩进

    def _file_header(self, guard_name: str, interface_name: str) -> str:
        """生成文件头"""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

        idl_file_comment = ""
        if self.idl_file_name:
            idl_file_comment = f"// Source IDL file: {self.idl_file_name}\n"

        return f"""#if !defined({guard_name})
#define {guard_name}

// This file is automatically generated by DAS IPC Message Generator
// Generated at: {timestamp}
{idl_file_comment}// !!! DO NOT EDIT !!!
//
// IPC message structures for {interface_name}
//

#include <das/Core/IPC/IPCMessageHeader.h>
#include <cstdint>

"""

    def _file_footer(self, guard_name: str) -> str:
        """生成文件尾"""
        return f"""
#endif // {guard_name}
"""

    def _generate_namespace_open(self, namespace: str) -> str:
        """生成命名空间开始标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i, part in enumerate(parts):
                indent = "    " * i
                result.append(f"{indent}namespace {part}")
                result.append(f"{indent}{{")
            return "\n".join(result) + "\n"
        return ""

    def _generate_namespace_close(self, namespace: str) -> str:
        """生成命名空间结束标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i in range(len(parts) - 1, -1, -1):
                indent = "    " * i
                result.append(f"{indent}}}")
            result.append(f"// namespace {namespace}")
            return "\n".join(result) + "\n"
        return ""

    def _generate_message_structs_for_method(self, interface: InterfaceDef, method: MethodDef) -> str:
        """为单个方法生成 Request/Response 消息结构体"""
        lines = []

        interface_short_name = IpcMessageTypeMapper.get_interface_short_name(interface.name)

        # 生成 Request 结构体
        request_struct_name = f"{interface_short_name}_{method.name}_Request"
        lines.append(f"struct alignas(8) {request_struct_name}")
        lines.append("{")
        lines.append(f"{self.indent}IPCMessageHeaderV2 header;")
        lines.append(f"{self.indent}// payload will be serialized separately")
        lines.append("};")
        lines.append("")

        # 生成 Response 结构体
        response_struct_name = f"{interface_short_name}_{method.name}_Response"
        lines.append(f"struct alignas(8) {response_struct_name}")
        lines.append("{")
        lines.append(f"{self.indent}IPCMessageHeaderV2 header;")

        # 检查返回值类型
        return_type = method.return_type.base_type
        if return_type != 'void':
            lines.append(f"{self.indent}// return value will be serialized separately")
        else:
            lines.append(f"{self.indent}// void return - no additional fields")

        lines.append("};")
        lines.append("")

        return "\n".join(lines)

    def _generate_messages_for_interface(self, interface: InterfaceDef, namespace_depth: int = 0) -> str:
        """为接口生成所有消息结构体"""
        lines = []

        indent = "    " * namespace_depth

        interface_short_name = IpcMessageTypeMapper.get_interface_short_name(interface.name)

        # 接口注释
        lines.append(f"{indent}// ============================================================================")
        lines.append(f"{indent}// {interface_short_name} IPC Messages")
        lines.append(f"{indent}// Interface: {interface.name}")
        lines.append(f"{indent}// Methods: {len(interface.methods)}")
        lines.append(f"{indent}// ============================================================================")
        lines.append("")

        # 为每个方法生成消息结构
        for method in interface.methods:
            method_code = self._generate_message_structs_for_method(interface, method)
            # 添加缩进
            for line in method_code.splitlines():
                lines.append(f"{indent}{line}" if line.strip() else "")

        return "\n".join(lines)

    def generate_message_header(self, output_dir: str) -> List[str]:
        """生成所有接口的 IPC 消息头文件

        Args:
            output_dir: 输出目录

        Returns:
            生成的文件路径列表
        """
        generated_files = []

        # 确保 messages 子目录存在
        messages_dir = os.path.join(output_dir, "messages")
        os.makedirs(messages_dir, exist_ok=True)

        # 按命名空间分组
        namespace_groups = {}
        no_namespace_interfaces = []

        for interface in self.document.interfaces:
            if interface.namespace:
                if interface.namespace not in namespace_groups:
                    namespace_groups[interface.namespace] = []
                namespace_groups[interface.namespace].append(interface)
            else:
                no_namespace_interfaces.append(interface)

        # 为每个命名空间组生成一个文件
        # 如果只有无命名空间的接口，生成一个汇总文件
        all_groups = list(namespace_groups.items())
        if no_namespace_interfaces:
            all_groups.append((None, no_namespace_interfaces))

        for namespace, interfaces in all_groups:
            if not interfaces:
                continue

            # 确定文件名
            if namespace:
                # 将命名空间转换为文件名格式
                ns_path = namespace.replace("::", ".")
                base_name = ns_path
            else:
                # 使用 IDL 文件名作为基础
                if self.idl_file_name:
                    base_name = os.path.splitext(self.idl_file_name)[0]
                else:
                    base_name = "IPC"

            filename = f"{base_name}Messages.h"
            filepath = os.path.join(messages_dir, filename)
            guard_name = f"DAS_IPC_{base_name.replace('.', '_').upper()}_MESSAGES_H"

            # 生成内容
            content = self._file_header(guard_name, namespace or "Global")

            # 生成命名空间包装
            ns_depth = 0
            if namespace:
                content += self._generate_namespace_open(namespace)
                ns_depth = len(namespace.split("::"))

                # 添加 Messages 命名空间
                ns_indent = "    " * ns_depth
                content += f"{ns_indent}namespace IPC\n"
                content += f"{ns_indent}{{\n"
                content += f"{ns_indent}namespace Messages\n"
                content += f"{ns_indent}{{\n"
                ns_depth += 2

            # 生成所有接口的消息结构
            for interface in interfaces:
                content += self._generate_messages_for_interface(interface, ns_depth)
                content += "\n"

            # 关闭命名空间
            if namespace:
                ns_indent = "    " * (ns_depth - 2)
                content += f"{ns_indent}}}\n"
                content += f"{ns_indent}}}\n"
                content += self._generate_namespace_close(namespace)

            content += self._file_footer(guard_name)

            # 写入文件
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)

            print(f"Generated: {filepath}")
            generated_files.append(filepath)

        return generated_files


def generate_ipc_message_files(
    document: IdlDocument,
    output_dir: str,
    base_name: Optional[str] = None,
    idl_file_path: Optional[str] = None
) -> List[str]:
    """生成 IPC 消息结构文件

    Args:
        document: IDL 文档对象
        output_dir: 输出目录
        base_name: 基础文件名（可选，默认使用 IDL 文件名）
        idl_file_path: IDL 文件路径（可选）

    Returns:
        生成的文件路径列表
    """
    generator = IpcMessageGenerator(document, idl_file_path)
    return generator.generate_message_header(output_dir)


# 测试代码
if __name__ == '__main__':
    parse_idl = _das_idl_parser.parse_idl

    test_idl = '''
    import "DasBasicTypes.idl";

    namespace Das::ExportInterface {

    [uuid("9BC34D72-E442-4944-ACE6-69257D262568")]
    interface IDasSourceLocation {
        [get, set] IDasReadOnlyString FileName;
        [get, set] int32_t Line;
        [get, set] IDasReadOnlyString FunctionName;
    };

    [uuid("F4191604-D061-49A4-85EC-28EFC376119F")]
    interface IDasLogReader : IDasBase {
        DasResult ReadOne(IDasReadOnlyString* message);
    }

    [uuid("806E244C-CCF0-4DC3-AD54-6886FDF9B1F4")]
    interface IDasLogRequester : IDasBase {
        DasResult RequestOne(IDasLogReader* p_reader);
    }

    }
    '''

    doc = parse_idl(test_idl)
    generator = IpcMessageGenerator(doc, "test.idl")

    print("=== 生成的 IPC 消息头文件 ===")
    files = generator.generate_message_header("./test_output")
    for f in files:
        print(f"  - {f}")
