"""
DAS IPC 序列化代码生成器

从 IDL 类型定义生成序列化/反序列化代码。

功能:
1. 为 IDL 基本类型生成 Serialize/Deserialize 函数
2. 为 IDL struct 生成递归序列化函数
3. 使用 SerializerWriter/SerializerReader API

输出文件命名: serializer/<Namespace>Serializers.h

生成的代码规范:
- inline 函数，便于头文件使用
- 返回 DasResult 表示成功/失败
- 支持嵌套 struct 序列化
"""

import os
from datetime import datetime, timezone
from pathlib import Path
from typing import List, Optional, Dict, Tuple
import importlib
import sys

# 既支持作为包内模块导入（tools.das_idl.*），也支持直接脚本运行。
try:
    from . import das_idl_parser as _das_idl_parser
except ImportError:
    this_dir = str(Path(__file__).resolve().parent)
    if this_dir not in sys.path:
        sys.path.insert(0, this_dir)
    _das_idl_parser = importlib.import_module("das_idl_parser")

IdlDocument = _das_idl_parser.IdlDocument
StructDef = _das_idl_parser.StructDef
StructFieldDef = _das_idl_parser.StructFieldDef
EnumDef = _das_idl_parser.EnumDef
TypeInfo = _das_idl_parser.TypeInfo


class IpcSerializerTypeMapper:
    """IPC 序列化类型映射器
    
    将 IDL 类型映射到:
    1. C++ 类型
    2. Write 方法名
    3. Read 方法名
    """
    
    # IDL 基本类型 → (C++类型, Write方法名, Read方法名, 需要指针参数)
    TYPE_MAP: Dict[str, Tuple[str, str, str, bool]] = {
        # 有符号整数
        'int8': ('int8_t', 'WriteInt8', 'ReadInt8', True),
        'int16': ('int16_t', 'WriteInt16', 'ReadInt16', True),
        'int32': ('int32_t', 'WriteInt32', 'ReadInt32', True),
        'int32_t': ('int32_t', 'WriteInt32', 'ReadInt32', True),
        'int64': ('int64_t', 'WriteInt64', 'ReadInt64', True),
        'int64_t': ('int64_t', 'WriteInt64', 'ReadInt64', True),
        # 无符号整数
        'uint8': ('uint8_t', 'WriteUInt8', 'ReadUInt8', True),
        'uint16': ('uint16_t', 'WriteUInt16', 'ReadUInt16', True),
        'uint32': ('uint32_t', 'WriteUInt32', 'ReadUInt32', True),
        'uint32_t': ('uint32_t', 'WriteUInt32', 'ReadUInt32', True),
        'uint64': ('uint64_t', 'WriteUInt64', 'ReadUInt64', True),
        'uint64_t': ('uint64_t', 'WriteUInt64', 'ReadUInt64', True),
        # 浮点数
        'float': ('float', 'WriteFloat', 'ReadFloat', True),
        'double': ('double', 'WriteDouble', 'ReadDouble', True),
        # 布尔
        'bool': ('bool', 'WriteBool', 'ReadBool', True),
        # 其他
        'char': ('char', 'WriteInt8', 'ReadInt8', True),
        'size_t': ('size_t', 'WriteUInt64', 'ReadUInt64', True),
    }
    
    # 特殊类型（需要特殊处理）
    SPECIAL_TYPES = {
        'string': ('std::string', 'WriteString', 'ReadString', True),
        'DasGuid': ('DasGuid', 'WriteGuid', 'ReadGuid', True),
    }
    
    @classmethod
    def get_type_info(cls, idl_type: str) -> Optional[Tuple[str, str, str, bool]]:
        """获取类型信息
        
        Args:
            idl_type: IDL 类型名称
            
        Returns:
            (cpp_type, write_method, read_method, needs_pointer) 或 None
        """
        # 先检查基本类型
        if idl_type in cls.TYPE_MAP:
            return cls.TYPE_MAP[idl_type]
        # 再检查特殊类型
        if idl_type in cls.SPECIAL_TYPES:
            return cls.SPECIAL_TYPES[idl_type]
        return None
    
    @classmethod
    def is_basic_type(cls, idl_type: str) -> bool:
        """检查是否是基本类型（可以直接序列化）"""
        return idl_type in cls.TYPE_MAP or idl_type in cls.SPECIAL_TYPES
    
    @classmethod
    def get_cpp_type(cls, idl_type: str) -> str:
        """获取 C++ 类型名"""
        info = cls.get_type_info(idl_type)
        if info:
            return info[0]
        # 未知类型，假设是 struct 名
        return idl_type


class IpcSerializerCodeGenerator:
    """IPC 序列化代码生成器"""
    
    def __init__(self, document: IdlDocument, idl_file_path: Optional[str] = None):
        self.document = document
        self.idl_file_path = idl_file_path
        self.idl_file_name = os.path.basename(idl_file_path) if idl_file_path else None
        self.indent = "    "  # 4 空格缩进
        self.type_mapper = IpcSerializerTypeMapper()
    
    def _file_header(self, guard_name: str, namespace: str) -> str:
        """生成文件头"""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        
        idl_file_comment = ""
        if self.idl_file_name:
            idl_file_comment = f"// Source IDL file: {self.idl_file_name}\n"
        
        ns_comment = f"// Namespace: {namespace}" if namespace else "// Global namespace"
        
        return f"""#if !defined({guard_name})
#define {guard_name}

// This file is automatically generated by DAS IPC Serializer Generator
// Generated at: {timestamp}
{idl_file_comment}// !!! DO NOT EDIT !!!
//
// IPC Serialization functions
{ns_comment}
//

#include <das/Core/IPC/Serializer.h>
#include <cstdint>
#include <string>

"""
    
    def _file_footer(self, guard_name: str) -> str:
        """生成文件尾"""
        return f"""
#endif // {guard_name}
"""
    
    def _generate_namespace_open(self, namespace: str) -> str:
        """生成命名空间开始标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i, part in enumerate(parts):
                indent = "    " * i
                result.append(f"{indent}namespace {part}")
                result.append(f"{indent}{{")
            return "\n".join(result) + "\n"
        return ""
    
    def _generate_namespace_close(self, namespace: str) -> str:
        """生成命名空间结束标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i in range(len(parts) - 1, -1, -1):
                indent = "    " * i
                result.append(f"{indent}}}")
            result.append(f"// namespace {namespace}")
            return "\n".join(result) + "\n"
        return ""
    
    def _generate_basic_type_serializer(self, idl_type: str, namespace_depth: int = 0) -> str:
        """为基本类型生成序列化函数
        
        Args:
            idl_type: IDL 类型名称
            namespace_depth: 命名空间深度（用于缩进）
            
        Returns:
            生成的代码字符串
        """
        type_info = self.type_mapper.get_type_info(idl_type)
        if not type_info:
            return f"// Unknown type: {idl_type}\n"
        
        cpp_type, write_method, read_method, needs_pointer = type_info
        indent = "    " * namespace_depth
        
        lines = []
        
        # Serialize 函数
        lines.append(f"{indent}// Serialize {idl_type}")
        lines.append(f"{indent}inline DasResult Serialize_{idl_type}(")
        lines.append(f"{indent}    SerializerWriter& writer,")
        if idl_type == 'string':
            lines.append(f"{indent}    const {cpp_type}& value)")
        else:
            lines.append(f"{indent}    {cpp_type} value)")
        lines.append(f"{indent}{{")
        lines.append(f"{indent}    return writer.{write_method}(value);")
        lines.append(f"{indent}}}")
        lines.append("")
        
        # Deserialize 函数
        lines.append(f"{indent}// Deserialize {idl_type}")
        lines.append(f"{indent}inline DasResult Deserialize_{idl_type}(")
        lines.append(f"{indent}    SerializerReader& reader,")
        lines.append(f"{indent}    {cpp_type}* value)")
        lines.append(f"{indent}{{")
        lines.append(f"{indent}    return reader.{read_method}(value);")
        lines.append(f"{indent}}}")
        lines.append("")
        
        return "\n".join(lines)
    
    def _generate_struct_serializer(self, struct: StructDef, namespace_depth: int = 0) -> str:
        """为 struct 生成序列化函数
        
        Args:
            struct: 结构体定义
            namespace_depth: 命名空间深度
            
        Returns:
            生成的代码字符串
        """
        indent = "    " * namespace_depth
        inner_indent = "    " * (namespace_depth + 1)
        
        lines = []
        
        # 文档注释
        lines.append(f"{indent}// ============================================================================")
        lines.append(f"{indent}// {struct.name} serialization")
        lines.append(f"{indent}// Fields: {len(struct.fields)}")
        lines.append(f"{indent}// ============================================================================")
        lines.append("")
        
        # Serialize 函数
        lines.append(f"{indent}inline DasResult Serialize_{struct.name}(")
        lines.append(f"{indent}    SerializerWriter& writer,")
        lines.append(f"{indent}    const {struct.name}& value)")
        lines.append(f"{indent}{{")
        
        # 写入对象开始标记
        lines.append(f"{inner_indent}DasResult result = writer.WriteObjectBegin();")
        lines.append(f"{inner_indent}if (DAS_FAILED(result))")
        lines.append(f"{inner_indent}{{")
        lines.append(f"{inner_indent}    return result;")
        lines.append(f"{inner_indent}}}")
        lines.append("")
        
        # 序列化每个字段
        for field in struct.fields:
            field_type_info = self.type_mapper.get_type_info(field.type_name)
            if field_type_info:
                # 基本类型
                cpp_type, write_method, _, _ = field_type_info
                lines.append(f"{inner_indent}result = writer.{write_method}(value.{field.name});")
            else:
                # 假设是另一个 struct，递归调用
                lines.append(f"{inner_indent}result = Serialize_{field.type_name}(writer, value.{field.name});")
            
            lines.append(f"{inner_indent}if (DAS_FAILED(result))")
            lines.append(f"{inner_indent}{{")
            lines.append(f"{inner_indent}    return result;")
            lines.append(f"{inner_indent}}}")
        
        lines.append("")
        
        # 写入对象结束标记
        lines.append(f"{inner_indent}return writer.WriteObjectEnd();")
        lines.append(f"{indent}}}")
        lines.append("")
        
        # Deserialize 函数
        lines.append(f"{indent}inline DasResult Deserialize_{struct.name}(")
        lines.append(f"{indent}    SerializerReader& reader,")
        lines.append(f"{indent}    {struct.name}* value)")
        lines.append(f"{indent}{{")
        
        # 读取对象开始标记
        lines.append(f"{inner_indent}DasResult result = reader.ReadObjectBegin();")
        lines.append(f"{inner_indent}if (DAS_FAILED(result))")
        lines.append(f"{inner_indent}{{")
        lines.append(f"{inner_indent}    return result;")
        lines.append(f"{inner_indent}}}")
        lines.append("")
        
        # 反序列化每个字段
        for field in struct.fields:
            field_type_info = self.type_mapper.get_type_info(field.type_name)
            if field_type_info:
                # 基本类型
                cpp_type, _, read_method, _ = field_type_info
                lines.append(f"{inner_indent}result = reader.{read_method}(&value->{field.name});")
            else:
                # 假设是另一个 struct，递归调用
                lines.append(f"{inner_indent}result = Deserialize_{field.type_name}(reader, &value->{field.name});")
            
            lines.append(f"{inner_indent}if (DAS_FAILED(result))")
            lines.append(f"{inner_indent}{{")
            lines.append(f"{inner_indent}    return result;")
            lines.append(f"{inner_indent}}}")
        
        lines.append("")
        
        # 读取对象结束标记
        lines.append(f"{inner_indent}return reader.ReadObjectEnd();")
        lines.append(f"{indent}}}")
        lines.append("")
        
        return "\n".join(lines)
    
    def _generate_enum_serializer(self, enum: EnumDef, namespace_depth: int = 0) -> str:
        """为 enum 生成序列化函数
        
        将 enum 作为 int32 序列化
        
        Args:
            enum: 枚举定义
            namespace_depth: 命名空间深度
            
        Returns:
            生成的代码字符串
        """
        indent = "    " * namespace_depth
        inner_indent = "    " * (namespace_depth + 1)
        
        lines = []
        
        # 文档注释
        lines.append(f"{indent}// ============================================================================")
        lines.append(f"{indent}// {enum.name} serialization (as int32)")
        lines.append(f"{indent}// ============================================================================")
        lines.append("")
        
        # Serialize 函数
        lines.append(f"{indent}inline DasResult Serialize_{enum.name}(")
        lines.append(f"{indent}    SerializerWriter& writer,")
        lines.append(f"{indent}    {enum.name} value)")
        lines.append(f"{indent}{{")
        lines.append(f"{inner_indent}return writer.WriteInt32(static_cast<int32_t>(value));")
        lines.append(f"{indent}}}")
        lines.append("")
        
        # Deserialize 函数
        lines.append(f"{indent}inline DasResult Deserialize_{enum.name}(")
        lines.append(f"{indent}    SerializerReader& reader,")
        lines.append(f"{indent}    {enum.name}* value)")
        lines.append(f"{indent}{{")
        lines.append(f"{inner_indent}int32_t temp;")
        lines.append(f"{inner_indent}DasResult result = reader.ReadInt32(&temp);")
        lines.append(f"{inner_indent}if (DAS_SUCCEEDED(result))")
        lines.append(f"{inner_indent}{{")
        lines.append(f"{inner_indent}    *value = static_cast<{enum.name}>(temp);")
        lines.append(f"{inner_indent}}}")
        lines.append(f"{inner_indent}return result;")
        lines.append(f"{indent}}}")
        lines.append("")
        
        return "\n".join(lines)
    
    def generate_serializer_header(self, output_dir: str) -> List[str]:
        """生成所有类型的序列化头文件
        
        Args:
            output_dir: 输出目录
            
        Returns:
            生成的文件路径列表
        """
        generated_files = []
        
        # 确保 serializer 子目录存在
        serializer_dir = os.path.join(output_dir, "serializer")
        os.makedirs(serializer_dir, exist_ok=True)
        
        # 按命名空间分组
        namespace_groups: Dict[str, List] = {
            'structs': {},
            'enums': {}
        }
        
        # 收集所有 struct
        for struct in self.document.structs:
            ns = struct.namespace or ""
            if ns not in namespace_groups['structs']:
                namespace_groups['structs'][ns] = []
            namespace_groups['structs'][ns].append(struct)
        
        # 收集所有 enum
        for enum in self.document.enums:
            ns = enum.namespace or ""
            if ns not in namespace_groups['enums']:
                namespace_groups['enums'][ns] = []
            namespace_groups['enums'][ns].append(enum)
        
        # 获取所有出现过的命名空间
        all_namespaces = set()
        for struct in self.document.structs:
            if struct.namespace:
                all_namespaces.add(struct.namespace)
        for enum in self.document.enums:
            if enum.namespace:
                all_namespaces.add(enum.namespace)
        
        # 如果没有任何命名空间，使用默认
        if not all_namespaces:
            all_namespaces.add("")
        
        # 为每个命名空间生成一个文件
        for namespace in all_namespaces:
            structs_in_ns = namespace_groups['structs'].get(namespace, [])
            enums_in_ns = namespace_groups['enums'].get(namespace, [])
            
            # 如果这个命名空间没有 struct 和 enum，跳过
            if not structs_in_ns and not enums_in_ns:
                continue
            
            # 确定文件名
            if namespace:
                ns_path = namespace.replace("::", ".")
                base_name = ns_path
            else:
                if self.idl_file_name:
                    base_name = os.path.splitext(self.idl_file_name)[0]
                else:
                    base_name = "IPC"
            
            filename = f"{base_name}Serializers.h"
            filepath = os.path.join(serializer_dir, filename)
            guard_name = f"DAS_IPC_{base_name.replace('.', '_').upper()}_SERIALIZERS_H"
            
            # 生成内容
            content = self._file_header(guard_name, namespace)
            
            # 生成命名空间包装
            ns_depth = 0
            if namespace:
                content += self._generate_namespace_open(namespace)
                ns_depth = len(namespace.split("::"))
                
                # 添加 IPC::Serializer 命名空间
                ns_indent = "    " * ns_depth
                content += f"{ns_indent}namespace IPC\n"
                content += f"{ns_indent}{{\n"
                content += f"{ns_indent}namespace Serializer\n"
                content += f"{ns_indent}{{\n"
                ns_depth += 2
            
            # 生成基本类型序列化函数（仅在有命名空间的文件中生成一次）
            if namespace:
                content += self._generate_basic_type_serializers(ns_depth)
            
            # 生成 enum 序列化函数
            if enums_in_ns:
                content += f"{'    ' * ns_depth}// Enum serializers\n"
                content += f"{'    ' * ns_depth}//\n\n"
                for enum in enums_in_ns:
                    content += self._generate_enum_serializer(enum, ns_depth)
            
            # 生成 struct 序列化函数
            if structs_in_ns:
                content += f"{'    ' * ns_depth}// Struct serializers\n"
                content += f"{'    ' * ns_depth}//\n\n"
                for struct in structs_in_ns:
                    content += self._generate_struct_serializer(struct, ns_depth)
            
            # 关闭命名空间
            if namespace:
                ns_indent = "    " * (ns_depth - 2)
                content += f"{ns_indent}}}\n"
                content += f"{ns_indent}}}\n"
                content += self._generate_namespace_close(namespace)
            
            content += self._file_footer(guard_name)
            
            # 写入文件
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"Generated: {filepath}")
            generated_files.append(filepath)
        
        return generated_files
    
    def _generate_basic_type_serializers(self, namespace_depth: int = 0) -> str:
        """生成所有基本类型的序列化函数
        
        Args:
            namespace_depth: 命名空间深度
            
        Returns:
            生成的代码字符串
        """
        indent = "    " * namespace_depth
        lines = []
        
        lines.append(f"{indent}// ============================================================================")
        lines.append(f"{indent}// Basic type serializers")
        lines.append(f"{indent}// ============================================================================")
        lines.append("")
        
        # 基本整数类型
        basic_types = [
            'int8', 'int16', 'int32', 'int64',
            'uint8', 'uint16', 'uint32', 'uint64',
            'float', 'double', 'bool',
        ]
        
        for type_name in basic_types:
            lines.append(self._generate_basic_type_serializer(type_name, namespace_depth))
        
        # string 类型
        lines.append(self._generate_basic_type_serializer('string', namespace_depth))
        
        # DasGuid 类型
        lines.append(self._generate_basic_type_serializer('DasGuid', namespace_depth))
        
        return "\n".join(lines)


def generate_ipc_serializer_files(
    document: IdlDocument,
    output_dir: str,
    base_name: Optional[str] = None,
    idl_file_path: Optional[str] = None
) -> List[str]:
    """生成 IPC 序列化文件
    
    Args:
        document: IDL 文档对象
        output_dir: 输出目录
        base_name: 基础文件名（可选，默认使用 IDL 文件名）
        idl_file_path: IDL 文件路径（可选）
        
    Returns:
        生成的文件路径列表
    """
    generator = IpcSerializerCodeGenerator(document, idl_file_path)
    return generator.generate_serializer_header(output_dir)


# 测试代码
if __name__ == '__main__':
    parse_idl = _das_idl_parser.parse_idl
    
    test_idl = '''
    import "DasBasicTypes.idl";

    namespace Das::Test {

    enum TestEnum {
        Value1 = 0,
        Value2 = 1,
        Value3 = 2,
    };

    struct Point {
        double x;
        double y;
    };

    struct Rect {
        double origin_x;
        double origin_y;
        double width;
        double height;
    };

    [uuid("9BC34D72-E442-4944-ACE6-69257D262568")]
    interface IDasTest : IDasBase {
        DasResult GetPoint([out] Point* p_point);
        DasResult SetRect(const Rect& rect);
    }

    }
    '''
    
    doc = parse_idl(test_idl)
    generator = IpcSerializerCodeGenerator(doc, "test.idl")
    
    print("=== IDL Document ===")
    print(f"Structs: {len(doc.structs)}")
    for s in doc.structs:
        print(f"  struct {s.name}: {[f.name for f in s.fields]}")
    print(f"Enums: {len(doc.enums)}")
    for e in doc.enums:
        print(f"  enum {e.name}: {[v.name for v in e.values]}")
    
    print("\n=== Generated Serializer Files ===")
    files = generator.generate_serializer_header("./test_output")
    for f in files:
        print(f"  - {f}")
