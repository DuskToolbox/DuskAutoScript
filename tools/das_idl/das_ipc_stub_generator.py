"""
DAS IPC Stub 代码生成器

从 IDL 接口定义生成 IPC Stub 代码，用于服务端接收和处理 IPC 调用。

功能:
1. 为每个接口生成 Stub 类
2. 使用 FNV-1a hash 计算 InterfaceId（与 Proxy 一致）
3. 生成 MethodTable 元数据（与 Proxy 一致）
4. 实现 Dispatch 方法，根据 method_id 分发到具体处理函数
5. 为每个方法生成 Handle 处理函数（解包参数 → 调用实现 → 打包返回值）

输出文件命名: stub/<InterfaceName>Stub.h

Stub 代码规范 (B6):
- static constexpr uint32_t InterfaceId = <FNV-1a hash>;
- static constexpr MethodMetadata MethodTable[] = {...};
- void Dispatch(uint16_t method_id, const void* request, void* response) override;
- 每个 Handle 方法:
  1. 从 request 解包参数
  2. 调用 impl_->Method(...)
  3. 将结果打包到 response
"""

import os
from datetime import datetime, timezone
from pathlib import Path
from typing import List, Optional
import importlib
import sys

# 既支持作为包内模块导入（tools.das_idl.*），也支持直接脚本运行。
try:
    from . import das_idl_parser as _das_idl_parser
except ImportError:
    this_dir = str(Path(__file__).resolve().parent)
    if this_dir not in sys.path:
        sys.path.insert(0, this_dir)
    _das_idl_parser = importlib.import_module("das_idl_parser")

IdlDocument = _das_idl_parser.IdlDocument
InterfaceDef = _das_idl_parser.InterfaceDef
MethodDef = _das_idl_parser.MethodDef
ParameterDef = _das_idl_parser.ParameterDef
TypeInfo = _das_idl_parser.TypeInfo
ParamDirection = _das_idl_parser.ParamDirection


def fnv1a_hash(data: str) -> int:
    """计算字符串的 FNV-1a 32-bit hash
    
    Args:
        data: 要计算 hash 的字符串
        
    Returns:
        32-bit FNV-1a hash 值
    """
    # FNV-1a parameters for 32-bit
    FNV_PRIME = 0x01000193
    FNV_OFFSET_BASIS = 0x811c9dc5
    
    hash_value = FNV_OFFSET_BASIS
    for char in data.encode('utf-8'):
        hash_value ^= char
        hash_value = (hash_value * FNV_PRIME) & 0xFFFFFFFF
    
    return hash_value


class IpcStubGenerator:
    """IPC Stub 代码生成器"""
    
    def __init__(self, document: IdlDocument, idl_file_path: Optional[str] = None):
        self.document = document
        self.idl_file_path = idl_file_path
        self.idl_file_name = os.path.basename(idl_file_path) if idl_file_path else None
        self.indent = "    "  # 4 空格缩进
    
    def _file_header(self, guard_name: str, interface_name: str) -> str:
        """生成文件头"""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        
        idl_file_comment = ""
        if self.idl_file_name:
            idl_file_comment = f"// Source IDL file: {self.idl_file_name}\n"
        
        return f"""#if !defined({guard_name})
#define {guard_name}

// This file is automatically generated by DAS IPC Stub Generator
// Generated at: {timestamp}
{idl_file_comment}// !!! DO NOT EDIT !!!
//
// IPC Stub for {interface_name}
//

#include <das/Core/IPC/IPCMessageHeader.h>
#include <das/Core/IPC/IStubBase.h>
#include <cstdint>
#include <string>

"""
    
    def _file_footer(self, guard_name: str) -> str:
        """生成文件尾"""
        return f"""
#endif // {guard_name}
"""
    
    def _generate_namespace_open(self, namespace: str) -> str:
        """生成命名空间开始标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i, part in enumerate(parts):
                indent = "    " * i
                result.append(f"{indent}namespace {part}")
                result.append(f"{indent}{{")
            return "\n".join(result) + "\n"
        return ""
    
    def _generate_namespace_close(self, namespace: str) -> str:
        """生成命名空间结束标记（Allman 风格）"""
        if namespace:
            parts = namespace.split("::")
            result = []
            for i in range(len(parts) - 1, -1, -1):
                indent = "    " * i
                result.append(f"{indent}}}")
            result.append(f"// namespace {namespace}")
            return "\n".join(result) + "\n"
        return ""
    
    def _get_cpp_type(self, type_info: TypeInfo) -> str:
        """将 IDL 类型转换为 C++ 类型"""
        TYPE_MAP = {
            'bool': 'bool',
            'int8': 'int8_t',
            'int16': 'int16_t',
            'int32': 'int32_t',
            'int32_t': 'int32_t',
            'int64': 'int64_t',
            'int64_t': 'int64_t',
            'uint8': 'uint8_t',
            'uint16': 'uint16_t',
            'uint32': 'uint32_t',
            'uint32_t': 'uint32_t',
            'uint64': 'uint64_t',
            'uint64_t': 'uint64_t',
            'float': 'float',
            'double': 'double',
            'size_t': 'size_t',
            'int': 'int32_t',
            'uint': 'uint32_t',
            'DasResult': 'DasResult',
            'DasBool': 'DasBool',
            'DasGuid': 'DasGuid',
            'char': 'char',
            'string': 'std::string',
        }
        
        base = TYPE_MAP.get(type_info.base_type, type_info.base_type)
        
        result = ""
        if type_info.is_const:
            result += "const "
        
        result += base
        
        if type_info.is_pointer:
            result += "*" * type_info.pointer_level
        
        if type_info.is_reference:
            result += "&"
        
        return result
    
    def _get_interface_short_name(self, interface_name: str) -> str:
        """从接口名获取短名称（去掉 I 前缀）
        
        IDasLogger -> DasLogger
        """
        if interface_name.startswith('IDas'):
            return interface_name[1:]
        if interface_name.startswith('I') and len(interface_name) > 1:
            return interface_name[1:]
        return interface_name
    
    def _generate_dispatch_method(self, interface: InterfaceDef, namespace_depth: int = 0) -> str:
        """生成 Dispatch 方法"""
        lines = []
        indent = "    " * (namespace_depth + 2)  # class + public
        inner_indent = "    " * (namespace_depth + 3)
        
        lines.append(f"{indent}void Dispatch(uint16_t method_id, const void* request, void* response) override")
        lines.append(f"{indent}{{")
        lines.append(f"{inner_indent}switch (method_id)")
        lines.append(f"{inner_indent}{{")
        
        for i, method in enumerate(interface.methods):
            lines.append(f"{inner_indent}case {i}:")
            lines.append(f"{inner_indent}    Handle{method.name}(request, response);")
            lines.append(f"{inner_indent}    break;")
        
        lines.append(f"{inner_indent}default:")
        lines.append(f"{inner_indent}    // Unknown method_id, ignore or return error")
        lines.append(f"{inner_indent}    break;")
        lines.append(f"{inner_indent}}}")
        lines.append(f"{indent}}}")
        
        return "\n".join(lines)
    
    def _generate_handle_method(self, interface: InterfaceDef, method: MethodDef, method_index: int, namespace_depth: int = 0) -> str:
        """生成单个方法的 Handle 处理函数（混合模式）
        
        混合模式 (B7):
        - IsLocal=true: 直接转发调用（本地模式通常不需要 Stub）
        - IsLocal=false: 解包参数 → 调用实现 → 打包返回值
        """
        lines = []
        indent = "    " * (namespace_depth + 2)  # class + private
        inner_indent = "    " * (namespace_depth + 3)
        
        interface_short_name = self._get_interface_short_name(interface.name)
        request_type = f"{interface_short_name}_{method.name}_Request"
        response_type = f"{interface_short_name}_{method.name}_Response"
        
        return_type = method.return_type.base_type
        has_return = return_type != 'void'
        
        # 方法签名
        lines.append(f"{indent}void Handle{method.name}(const void* request, void* response)")
        lines.append(f"{indent}{{")
        
        # if constexpr (IsLocal) 分支
        lines.append(f"{inner_indent}if constexpr (IsLocal)")
        lines.append(f"{inner_indent}{{")
        lines.append(f"{inner_indent}    // Local mode: direct call (should not reach here in normal usage)")
        lines.append(f"{inner_indent}    (void)request;")
        lines.append(f"{inner_indent}    (void)response;")
        lines.append(f"{inner_indent}}}")
        lines.append(f"{inner_indent}else")
        lines.append(f"{inner_indent}{{")
        
        deeper_indent = inner_indent + "    "
        
        # Step 1: Cast request and response pointers
        lines.append(f"{deeper_indent}const {request_type}* req = static_cast<const {request_type}*>(request);")
        lines.append(f"{deeper_indent}{response_type}* resp = static_cast<{response_type}*>(response);")
        lines.append(f"{deeper_indent}(void)resp;")
        lines.append("")
        
        # Step 2: Unpack parameters (placeholder)
        lines.append(f"{deeper_indent}// TODO: Unpack parameters from request")
        unpack_params = []
        for param in method.parameters:
            param_type = self._get_cpp_type(param.type_info)
            lines.append(f"{deeper_indent}// {param.name}: {param_type}")
            unpack_params.append(f"/* {param.name} */")
        lines.append("")
        
        # Step 3: Call implementation
        params_str = ", ".join(unpack_params) if unpack_params else ""
        if has_return:
            cpp_return_type = self._get_cpp_type(method.return_type)
            lines.append(f"{deeper_indent}// {cpp_return_type} result = impl_->{method.name}({params_str});")
            lines.append(f"{deeper_indent}impl_->{method.name}({params_str});")
        else:
            lines.append(f"{deeper_indent}impl_->{method.name}({params_str});")
        lines.append("")
        
        # Step 4: Pack response (placeholder)
        lines.append(f"{deeper_indent}// TODO: Pack response")
        if has_return:
            lines.append(f"{deeper_indent}// resp->result = result;")
        
        lines.append(f"{inner_indent}}}")
        
        lines.append(f"{indent}}}")
        
        return "\n".join(lines)
    
    def _generate_stub_class(self, interface: InterfaceDef, namespace_depth: int = 0) -> str:
        """为接口生成混合模式 Stub 类 (B7)
        
        模板参数:
        - IsLocal=true: 本地模式（通常不需要 Stub，直接调用实现）
        - IsLocal=false: IPC 远程模式，接收并处理 IPC 调用
        """
        lines = []
        indent = "    " * namespace_depth
        class_indent = "    " * (namespace_depth + 1)
        method_indent = "    " * (namespace_depth + 2)
        
        interface_short_name = self._get_interface_short_name(interface.name)
        class_name = f"{interface_short_name}Stub"
        interface_id = fnv1a_hash(interface.name)
        
        # 类文档注释
        lines.append(f"{indent}// ============================================================================")
        lines.append(f"{indent}// {class_name}<IsLocal>")
        lines.append(f"{indent}// Hybrid IPC Stub for {interface.name}")
        lines.append(f"{indent}// Interface UUID: {interface.uuid}")
        lines.append(f"{indent}// ============================================================================")
        lines.append("")
        
        # 模板类定义
        lines.append(f"{indent}template <bool IsLocal>")
        lines.append(f"{indent}class {class_name} : public IStubBase")
        lines.append(f"{indent}{{")
        lines.append(f"{indent}public:")
        
        # InterfaceId 常量
        lines.append(f"{class_indent}static constexpr uint32_t InterfaceId = 0x{interface_id:08X}u;")
        lines.append("")
        
        # MethodTable 常量
        lines.append(f"{class_indent}static constexpr MethodMetadata MethodTable[] = {{")
        for i, method in enumerate(interface.methods):
            method_hash = fnv1a_hash(f"{interface.name}::{method.name}")
            lines.append(f"{method_indent}{{ /* method_id */ {i}, /* name */ \"{method.name}\", /* hash */ 0x{method_hash:08X}u }},")
        lines.append(f"{class_indent}}};")
        lines.append("")
        
        # 构造函数
        lines.append(f"{class_indent}explicit {class_name}({interface.name}* impl)")
        lines.append(f"{class_indent}    : impl_(impl)")
        lines.append(f"{class_indent}{{")
        lines.append(f"{class_indent}}}")
        lines.append("")
        
        # Dispatch 方法
        lines.append(self._generate_dispatch_method(interface, namespace_depth))
        lines.append("")
        
        # 私有成员
        lines.append(f"{indent}private:")
        
        # Handle 方法
        for i, method in enumerate(interface.methods):
            lines.append(self._generate_handle_method(interface, method, i, namespace_depth))
            lines.append("")
        
        # 实现指针
        lines.append(f"{class_indent}{interface.name}* impl_;")
        
        lines.append(f"{indent}}};")
        lines.append("")
        
        # 类型别名
        lines.append(f"{indent}using {interface_short_name}StubLocal = {class_name}<true>;")
        lines.append(f"{indent}using {interface_short_name}StubRemote = {class_name}<false>;")
        lines.append("")
        
        return "\n".join(lines)
    
    def generate_stub_headers(self, output_dir: str) -> List[str]:
        """生成所有接口的 IPC Stub 头文件
        
        Args:
            output_dir: 输出目录
            
        Returns:
            生成的文件路径列表
        """
        generated_files = []
        
        # 确保 stub 子目录存在
        stub_dir = os.path.join(output_dir, "stub")
        os.makedirs(stub_dir, exist_ok=True)
        
        # 为每个接口生成一个 Stub 文件
        for interface in self.document.interfaces:
            interface_short_name = self._get_interface_short_name(interface.name)
            filename = f"{interface_short_name}Stub.h"
            filepath = os.path.join(stub_dir, filename)
            
            # 生成 guard name
            ns_prefix = ""
            if interface.namespace:
                ns_prefix = interface.namespace.replace("::", "_") + "_"
            guard_name = f"DAS_IPC_{ns_prefix}{interface_short_name.upper()}_STUB_H"
            
            # 生成内容
            content = self._file_header(guard_name, interface.name)
            
            # 生成命名空间包装
            ns_depth = 0
            if interface.namespace:
                content += self._generate_namespace_open(interface.namespace)
                ns_depth = len(interface.namespace.split("::"))
                
                # 添加 Stub 命名空间
                ns_indent = "    " * ns_depth
                ns_indent_inner = "    " * (ns_depth + 1)
                content += f"{ns_indent}namespace IPC\n"
                content += f"{ns_indent}{{\n"
                content += f"{ns_indent_inner}namespace Stub\n"
                content += f"{ns_indent_inner}{{\n"
                ns_depth += 2
            
            # 生成 Stub 类
            content += self._generate_stub_class(interface, ns_depth)
            
            # 关闭命名空间
            if interface.namespace:
                ns_indent = "    " * (ns_depth - 2)
                ns_indent_inner = "    " * (ns_depth - 1)
                content += f"{ns_indent_inner}}}\n"
                content += f"{ns_indent_inner}// namespace Stub\n"
                content += f"{ns_indent}}}\n"
                content += f"{ns_indent}// namespace IPC\n"
                content += self._generate_namespace_close(interface.namespace)
            
            content += self._file_footer(guard_name)
            
            # 写入文件
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"Generated: {filepath}")
            generated_files.append(filepath)
        
        return generated_files


def generate_ipc_stub_files(
    document: IdlDocument,
    output_dir: str,
    base_name: Optional[str] = None,
    idl_file_path: Optional[str] = None
) -> List[str]:
    """生成 IPC Stub 文件
    
    Args:
        document: IDL 文档对象
        output_dir: 输出目录
        base_name: 基础文件名（可选，默认使用 IDL 文件名）
        idl_file_path: IDL 文件路径（可选）
        
    Returns:
        生成的文件路径列表
    """
    generator = IpcStubGenerator(document, idl_file_path)
    return generator.generate_stub_headers(output_dir)


# 测试代码
if __name__ == '__main__':
    parse_idl = _das_idl_parser.parse_idl
    
    test_idl = '''
    import "DasBasicTypes.idl";

    namespace Das::ExportInterface {

    [uuid("9BC34D72-E442-4944-ACE6-69257D262568")]
    interface IDasSourceLocation {
        [get, set] IDasReadOnlyString FileName;
        [get, set] int32_t Line;
        [get, set] IDasReadOnlyString FunctionName;
    };

    [uuid("F4191604-D061-49A4-85EC-28EFC376119F")]
    interface IDasLogReader : IDasBase {
        DasResult ReadOne(IDasReadOnlyString* message);
    }

    [uuid("806E244C-CCF0-4DC3-AD54-6886FDF9B1F4")]
    interface IDasLogRequester : IDasBase {
        DasResult RequestOne(IDasLogReader* p_reader);
    }

    }
    '''

    doc = parse_idl(test_idl)
    generator = IpcStubGenerator(doc, "test.idl")
    
    print("=== 生成的 IPC Stub 头文件 ===")
    files = generator.generate_stub_headers("./test_output")
    for f in files:
        print(f"  - {f}")
