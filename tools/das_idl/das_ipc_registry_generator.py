"""
DAS IPC Registry 代码生成器

从 interface.json 文件生成 Proxy Registry 代码。

功能:
1. 读取所有 interface.json 文件
2. 检测 interface_id 冲突
3. 生成 ProxyRegistry.h（包含所有 Proxy 的注册信息）

输出文件: registry/ProxyRegistry.h
"""

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Any


def generate_ipc_registry(cache_dir: str, output_dir: str) -> List[str]:
    """生成 IPC Registry 文件
    
    Args:
        cache_dir: 缓存目录（包含 interface.json 文件）
        output_dir: 输出目录
        
    Returns:
        生成的文件路径列表
    """
    generated_files = []
    
    registry_dir = os.path.join(output_dir, "registry")
    os.makedirs(registry_dir, exist_ok=True)
    
    interfaces: List[Dict[str, Any]] = []
    interface_id_map: Dict[str, List[str]] = {}
    
    if os.path.exists(cache_dir):
        for filename in os.listdir(cache_dir):
            if filename.endswith('.json'):
                filepath = os.path.join(cache_dir, filename)
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    interfaces.append(data)
                    
                    interface_id = data.get('interface_id', '')
                    interface_name = data.get('interface_name', 'unknown')
                    
                    if interface_id not in interface_id_map:
                        interface_id_map[interface_id] = []
                    interface_id_map[interface_id].append(interface_name)
                except Exception as e:
                    print(f"Warning: Failed to read {filepath}: {e}")
    
    conflicts = []
    for interface_id, names in interface_id_map.items():
        if len(names) > 1:
            conflicts.append((interface_id, names))
    
    if conflicts:
        print("ERROR: Interface ID conflicts detected:")
        for interface_id, names in conflicts:
            print(f"  {interface_id}: {', '.join(names)}")
        raise ValueError(f"Interface ID conflicts detected: {len(conflicts)} conflicts")
    
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    
    content = f"""#if !defined(DAS_IPC_PROXY_REGISTRY_H)
#define DAS_IPC_PROXY_REGISTRY_H

// This file is automatically generated by DAS IPC Registry Generator
// Generated at: {timestamp}
// !!! DO NOT EDIT !!!
//
// IPC Proxy Registry - interface_id to Proxy factory mapping
//

#include <cstdint>
#include <functional>
#include <unordered_map>

DAS_NS_BEGIN
namespace Core
{{
namespace IPC
{{

struct ProxyFactoryInfo
{{
    uint32_t interface_id;
    const char* interface_name;
    const char* uuid;
}};

class ProxyRegistry
{{
public:
    static ProxyRegistry& Instance()
    {{
        static ProxyRegistry instance;
        return instance;
    }}
    
    const ProxyFactoryInfo* FindByInterfaceId(uint32_t interface_id) const
    {{
        auto it = registry_.find(interface_id);
        if (it != registry_.end())
            return &it->second;
        return nullptr;
    }}
    
    bool RegisterProxy(const ProxyFactoryInfo& info)
    {{
        if (registry_.find(info.interface_id) != registry_.end())
            return false;
        registry_[info.interface_id] = info;
        return true;
    }}

private:
    ProxyRegistry()
    {{
        InitializeBuiltinProxies();
    }}
    
    void InitializeBuiltinProxies();
    
    std::unordered_map<uint32_t, ProxyFactoryInfo> registry_;
}};

inline void ProxyRegistry::InitializeBuiltinProxies()
{{
"""

    for iface in interfaces:
        interface_id = iface.get('interface_id', '0x00000000')
        interface_name = iface.get('interface_name', 'Unknown')
        uuid = iface.get('uuid', '')
        namespace_str = iface.get('namespace', '')
        
        content += f"""    RegisterProxy({{ 0x{interface_id[2:]}, "{interface_name}", "{uuid}" }});
"""

    content += f"""}}

}}
}}
DAS_NS_END

#endif // DAS_IPC_PROXY_REGISTRY_H
"""

    filepath = os.path.join(registry_dir, "ProxyRegistry.h")
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"Generated: {filepath}")
    generated_files.append(filepath)
    
    return generated_files


if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='DAS IPC Registry Generator')
    parser.add_argument('--cache-dir', required=True, help='Cache directory with interface.json files')
    parser.add_argument('--output-dir', required=True, help='Output directory')
    
    args = parser.parse_args()
    
    files = generate_ipc_registry(args.cache_dir, args.output_dir)
    for f in files:
        print(f"  - {f}")
